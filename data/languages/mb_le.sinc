define endian     = $(ENDIAN);
define alignment  = 4;

define space ram      type=ram_space        size=4 default;
define space register type=register_space   size=4;

define register offset=0 size=4
  [ r0 r1 r2 r3 r4 r5 r6 r7	r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31 ];

define register offset=0x80 size=4
  [ pc msr ear esr fsr btr edr slr shr pid zpr tlblo tlbhi tlbx tlbsx ] ;

define register offset=0xBC size=4
  [ pvr0 pvr1 pvr2 pvr3 pvr4 pvr5 pvr6 pvr7 pvr8 pvr9 pvr10 pvr11 pvr12 ] ;

define register offset=0xF0 size=1
  [ cf ] ;

define bitrange cc=msr[0,1] #reserved omitted
                vms=msr[17,1]
                vm=msr[18,1]
                ums=msr[19,1]
                um=msr[20,1]
                pvr=msr[21,1]
                eip=msr[22,1]
                ee=msr[23,1]
                dce=msr[24,1]
                dzo=msr[25,1]
                ice=msr[26,1]
                fsl=msr[27,1]
                bip=msr[28,1]
                c=msr[29,1]
                ie=msr[30,1]
;

define bitrange io=fsr[27,1]
                dz=fsr[28,1]
                of=fsr[29,1]
                uf=fsr[30,1]
                do=fsr[31,1]
;

define bitrange ds=esr[12,1]
                ess=esr[5,7]
                ec=esr[0,5]
;

define token instr(32)
      op2631 = (26,31)
      op2931 = (29,31)
      op0026 = (26,26)
      op_k = (28,28)
      op_c = (27,27)
      op_rsub = (26,26)
      rD = (21,25)
      rA = (16,20)
      rB = (11,15)
      rS = (0,13)
      cd0010 = (0,10)
      cd0015 = (0,15)
      cd0415 = (4,15)
      cd0505 = (5,5)
      cd1415 = (14,15)
      cd1620 = (16,20)
      cd2125 = (21,25)
      imm = (0,15)
      immw = (6,10)
      imms = (0,4)
      imm3 = (21,25)
      imm14= (0,13)
      bs1115 = (11,15)
      bs0510 = (5,10)
      zr1415 = (14,15)
      fsl = (0,3)
;

attach variables [ rD rA rB ] [ r0 r1 r2 r3 r4 r5 r6 r7	r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31 ];

kp: "k" is op_k=1 { }
kp:     is op_k=0 { c = cf; cc = cf; }

cy: "c" is op_c=1 { rD = rD + c; }
cy:     is op_c=0 { }
cy:     is op_c=0 & op_rsub=0b1 { rD = rD + 1; }

:add^kp^cy rD, rA, rB is op2931=0b000 & op_k & op_c & op_rsub=0b0 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA + rB;
  build cy;
	cf = scarry(rA, rB);
	build kp;
}

:rsub^kp^cy rD, rA, rB is op2931=0b000 & op_k & op_c & op_rsub=0b1 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rB + ~rA;
  cf = scarry(rA, rB);
  build kp;
}

:cmp rD, rA, rB is op2631=0b000101 & rD & rA & rB & cd0010=0b00000000001 {
	rD = rB + ~rA + 1;
  rD[31,1] = (rA s> rB);
}

:cmpu rD, rA, rB is op2631=0b000101 & rD & rA & rB & cd0010=0b00000000011 {
	rD = rB + ~rA + 1;
	rD[31,1] = (rA > rB);
}

:addi^kp^cy rD, rA, imm is op2931=0b001 & op_k & op_c & op_rsub=0b0 & rD & rA & imm {
  rD = rA + imm;
  build cy;
  cf = scarry(rA, imm);
  build kp;
}

:rsubi^kp^cy rD, rA, imm is op2931=0b001 & op_k & op_c & op_rsub=0b1 & rD & rA & imm {
  rD = imm + ~rA;
  cf = scarry(rA, imm);
  build kp;
}

:mul rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000000 {
	rD = (rA * rB);
}

:mulh rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000001 {
	rD = (sext(rA) * sext(rB)) s>> 32;
}

:mulhu rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000011 {
	rD = (zext(rA) * zext(rB)) >> 32;
}

:mulhsu rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000010 {
	rD = (sext(rA) * zext(rB)) s>> 32;
}

:bsrl rD, rA, rB is op2631=0b010001 & rD & rA & rB & cd0010=0b00000000000 {
	rD = 0 & (rA >> rB);
}

:bsra rD, rA, rB is op2631=0b010001 & rD & rA & rB & cd0010=0b01000000000 {
	rD = rA s>> rB;
}

:bsll rD, rA, rB is op2631=0b010001 & rD & rA & rB & cd0010=0b10000000000 {
	rD = (rA << rB) & 0;
}

:idiv rD, rA, rB is op2631=0b010010 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rB s/ rA;
}

:idivu rD, rA, rB is op2631=0b010010 & rD & rA & rB & cd0010=0b00000000010 {
	rD = rB / rA;
}

:tneagetd.t rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b000100000000 unimpl

:tneagetd.n rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b010000000000 unimpl

:tneagetd.e rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b000000100000 unimpl

:tneagetd.a rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b000001000000 unimpl

:tnecagetd.t rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b00110000000 unimpl

:tnecagetd.n rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b01100000000 unimpl

:tnecagetd.e rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b00100100000 unimpl

:tnecagetd.a rD, rB is op2631=0b110010 & rD & rB & cd1620=0 & cd0010=0b00101000000 unimpl

:naputd.n rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b11000000000 unimpl

:naputd.a rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b10001000000 unimpl

:tnaputd.n rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b11010000000 unimpl

:tnaputd.a rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b10011000000 unimpl

:ncaputd.n rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b11100000000 unimpl

:ncaputd.a rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b10101000000 unimpl

:tncaputd.n rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b1111000000 unimpl

:tncaputd.a rA, rB is op2631=0b010011 & cd2125=0 & rA & rB & cd0010=0b1011100000 unimpl

:fadd rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00000000000 {
    rD = rB f+ rA;
}

:frsub rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00010000000 {
  rD = rB f- rA;
}

:fmul rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00100000000 {
  rD = rB f* rA;
}

:fdiv rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00110000000 {
  rD = rB f/ rA;
}

:fcmp.un rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000000000 {
  rD = nan(rA) || nan(rB);
}

:fcmp.lt rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000010000{
  rD = rB f< rA;
}

:fcmp.eq rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000100000 {
  rD = rB f== rA;
}

:fcmp.le rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000110000 {
  rD = rB f<= rA;
}

:fcmp.gt rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001000000 {
  rD = rB f> rA;
}

:fcmp.ne rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001010000 {
  rD = rB f!= rA;
}

:fcmp.ge rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001100000 {
  rD = rB f>= rA;
}

:flt rD, rA is op2631=0b010110 & rD & rA & cd0015=0b0000001010000000 {
  rD = int2float(rA);
}

:fint rD, rA is op2631=0b010110 & rD & rA & cd0015=0b0000001100000000 {
  rD = trunc(rA);
}

:fsqrt rD, rA is op2631=0b010110 & rD & rA & cd0015=0b0000001110000000 {
  rD = sqrt(rA);
}

:muli rD, rA, imm is op2631=0b011000 & rD & rA & imm {
	rD = rA * imm;
}

:bsrli rD, rA, imms is op2631=0b011001 & rD & rA & bs1115=0b00000 & bs0510=0b000000 & imms {
	rD = 0 & (rA >> imms);
}

:bsrai rD, rA, imms is op2631=0b011001 & rD & rA & bs1115=0b00000 & bs0510=0b010000 & imms {
	rD = rA s>> imms;
}

:bslli rD, rA, imms is op2631=0b011001 & rD & rA & bs1115=0b00000 & bs0510=0b100000 & imms {
	rD = (rA << imms) & 0;
}

:bsefi rD, rA, immw, imms is op2631=0b011001 & rD & rA & bs1115=0b01000 & immw & cd0505=0 & imms {

}

:bsifi rD, rA, immw, imms is op2631=0b011001 & rD & rA & bs1115=0b10000 & immw & cd0505=0 & imms unimpl

:tneaget.t rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b000100000000 & fsl unimpl

:tneaget.n rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b010000000000 & fsl unimpl

:tneaget.e rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b000001000000 & fsl unimpl

:tneaget.a rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b000010000000 & fsl unimpl

:tnecaget.t rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b001100000000 & fsl unimpl

:tnecaget.n rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b011000000000 & fsl unimpl

:tnecaget.e rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b001001000000 & fsl unimpl

:tnecaget.a rD, fsl is op2631=0b011011 & rD & cd1620=0 & cd0415=0b001010000000 & fsl unimpl

:naput.n rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b110000000000 & fsl unimpl

:naput.a rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b100010000000 & fsl unimpl

:tnaput.n rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b110100000000 & fsl unimpl

:tnaput.a rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b100110000000 & fsl unimpl

:ncaput.n rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b111000000000 & fsl unimpl

:ncaput.a rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b101000000000 & fsl unimpl

:tncaput.n rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b111100000000 & fsl unimpl

:tncaput.a rA, fsl is op2631=0b011011 & cd2125=0 & rA & cd0415=0b101110000000 & fsl unimpl

:or rD, rA, rB is op2631=0b100000 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA | rB;
}

:pcmpbf rD, rA, rB is op2631=0b100000 & rD & rA & rB & cd0010=0b10000000000 unimpl

:and rD, rA, rB is op2631=0b100001 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA & rB;
}

:xor rD, rA, rB is op2631=0b100010 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA ^ rB;
}

:pcmpeq rD, rA, rB is op2631=0b100010 & rD & rA & rB & cd0010=0b10000000000 unimpl

:andn rD, rA, rB is op2631=0b100011 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA & ~rB;
}
:pcmpne rD, rA, rB is op2631=0b100011 & rD & rA & rB & cd0010=0b10000000000 unimpl
:sra rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000000000001 {
	rD = rA s>> 1;
}
:src rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000000100001 unimpl
:srl rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000001000001 unimpl
:sext8 rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000001100000 {
	local tmp:1 = rA[0,8];
	rD = sext(tmp);
}
:sext16 rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000001100001 {
	local tmp:2 = rA[0,16];
	rD = sext(tmp);
}
:clz rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000011100000 unimpl
:swapb rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000111100000 unimpl
:swaph rD, rA is op2631=0b100100 & rD & rA & cd0015=0b0000000111100010 unimpl
:wic rA, rB is op2631=0b100100 & cd2125=0b00000 & rA & rB & cd0010=0b00001101000 unimpl
:wdc rA, rB is op2631=0b100100 & cd2125=0b00000 & rA & rB & cd0010=0b00001100100 unimpl
:wdc.flush rA, rB is op2631=0b100100 & cd2125=0b00000 & rA & rB & cd0010=0b00001110100 unimpl
:wdc.clear rA, rB is op2631=0b100100 & cd2125=0b00000 & rA & rB & cd0010=0b00001100110 unimpl
:wdc.clear.ea rA, rB is op2631=0b100100 & cd2125=0b00000 & rA & rB & cd0010=0b00011100110 unimpl
:mts rS, rA is op2631=0b100101 & cd2125=0 & rA & cd1415=0b11 & rS unimpl
:mtse rS, rA is op2631=0b100101 & cd2125=0b01000 & rA & cd1415=0b11 & rS unimpl
:mfs rD, rS is op2631=0b100101 & rD & cd1620=0 & cd1415=0b11 & rS unimpl
:mfse rD, rS is op2631=0b100101 & rD & cd1620=0b01000 & cd1415=0b10 & rS unimpl
:msrclr rD, imm14 is op2631=0b100101 & rD & cd1620=0b00001 & zr1415=0 & imm14 unimpl
:msrset rD, imm14 is op2631=0b100101 & rD & cd1620=0b00000 & zr1415=0 & imm14 unimpl
:br rB is op2631=0b100110 & cd2125=0 & cd1620=0 & rB & cd0010=0b00000000000 unimpl
:brd rB is op2631=0b100110 & cd2125=0 & cd1620=0b10000 & rB & cd0010=0b00000000000 unimpl
:brld rD, rB is op2631=0b100110 & rD & cd1620=0b10100 & rB & cd0010=0b00000000000 unimpl
:bra rB is op2631=0b100110 & cd2125=0 & cd1620=0b01000 & rB & cd0010=0b00000000000 {
	local tmp:4 = rB;
    goto [tmp];
}
:brad rB is op2631=0b100110 & cd2125=0 & cd1620=0b11000 & rB & cd0010=0b00000000000 unimpl
:brald rD, rB is op2631=0b100110 & rD & cd1620=0b11100 & rB & cd0010=0b00000000000 {
	rD = inst_start;
    local tmp:4 = rB;
    delayslot(1);
    call [tmp];
}
:brk rD, rB is op2631=0b100110 & rD & cd1620=0b01100 & rB & cd0010=0b00000000000 unimpl
:beq rA, rB is op2631=0b100111 & cd2125=0b00000 & rA & rB & cd0010=0b00000000000 {
	if (rA == 0) goto rB;
}
:bne rA, rB is op2631=0b100111 & cd2125=0b00001 & rA & rB & cd0010=0b00000000000 {
	if (rA != 0) goto rB;
}
:blt rA, rB is op2631=0b100111 & cd2125=0b00010 & rA & rB & cd0010=0b00000000000 {
	if (rA s< 0) goto rB;
}
:ble rA, rB is op2631=0b100111 & cd2125=0b00011 & rA & rB & cd0010=0b00000000000 {
	if (rA s<= 0) goto rB;
}
:bgt rA, rB is op2631=0b100111 & cd2125=0b00100 & rA & rB & cd0010=0b00000000000 {
	if (rA s> 0) goto rB;
}
:bge rA, rB is op2631=0b100111 & cd2125=0b00101 & rA & rB & cd0010=0b00000000000 {
	if (rA s>= 0) goto rB;
}
:beqd rA, rB is op2631=0b100111 & cd2125=0b10000 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA == 0) goto rB;
}
:bned rA, rB is op2631=0b100111 & cd2125=0b10001 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA != 0) goto rB;
}
:bltd rA, rB is op2631=0b100111 & cd2125=0b10010 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA s< 0) goto rB;
}
:bled rA, rB is op2631=0b100111 & cd2125=0b10011 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA s<= 0) goto rB;
}
:bgtd rA, rB is op2631=0b100111 & cd2125=0b10100 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA s> 0) goto rB;
}
:bged rA, rB is op2631=0b100111 & cd2125=0b10101 & rA & rB & cd0010=0b00000000000 {
	delayslot(1);
	if (rA s>= 0) goto rB;
}
:ori rD, rA, imm is op2631=0b101000 & rD & rA & imm {
	rD = rA | imm;
}
:andi rD, rA, imm is op2631=0b101001 & rD & rA & imm {
	rD = rA & imm;
}
:xori rD, rA, imm is op2631=0b101010 & rD & rA & imm {
	rD = rA ^ imm;
}
:andni rD, rA, imm is op2631=0b101011 & rD & rA & imm {
	rD = rA & imm;
}
:imm imm is op2631=0b101100 & cd2125=0b00000 & cd1620=0b00000 & imm {
	imm[0,16] = imm;
}
:rtsd rA, imm is op2631=0b101101 & cd2125=0b10000 & rA & imm {
	delayslot(1);
    return [imm];
}
:rtid rA, imm is op2631=0b101101 & cd2125=0b10001 & rA & imm {
	delayslot(1);

	return [imm];
}
:rtbd rA, imm is op2631=0b101101 & cd2125=0b10010 & rA & imm unimpl
:rted rA, imm is op2631=0b101101 & cd2125=0b10100 & rA & imm unimpl
:bri imm is op2631=0b101110 & cd2125=0 & cd1620=0 & imm {
	goto imm;
}
:mbar imm3 is op2631=0b101110 & imm3 & cd1620=0b00010 & cd0015=0b0000000000000100 unimpl
:brid imm is op2631=0b101110 & cd2125=0 & cd1620=0b10000 & imm {
	delayslot(1);
	goto imm;
}
:brlid rD, imm is op2631=0b101110 & rD & cd1620=0b10100 & imm {
	rD = inst_start;
	local tmp:4 = imm;
	delayslot(1);
	call [tmp];
}
:brai imm is op2631=0b101110 & cd2125=0 & cd1620=0b01000 & imm {
	goto imm;
}
:braid imm is op2631=0b101110 & cd2125=0 & cd1620=0b11000 & imm unimpl
:bralid rD is op2631=0b101110 & rD & cd1620=0b11100 & imm unimpl
:brki rD, imm is op2631=0b101110 & rD & cd1620=0b01100 & imm unimpl
:beqi rA, imm is op2631=0b101111 & cd2125=0b00000 & rA & imm {
	delayflag:1 = (rA == 0);
    if delayflag goto imm;
}
:bnei rA, imm is op2631=0b101111 & cd2125=0b00001 & rA & imm {
	delayflag:1 = (rA != 0);
    if delayflag goto imm;
}
:blti rA, imm is op2631=0b101111 & cd2125=0b00010 & rA & imm {
	if (rA s< 0) goto imm;
}
:blei rA, imm is op2631=0b101111 & cd2125=0b00011 & rA & imm {
	delayflag:1 = (rA s<= 0);
    if delayflag goto imm;
}
:bgti rA, imm is op2631=0b101111 & cd2125=0b00100 & rA & imm {
	if (rA s> 0) goto imm;
}
:bgei rA, imm is op2631=0b101111 & cd2125=0b00101 & rA & imm {
	if (rA s>= 0) goto imm;
}
:beqid rA, imm is op2631=0b101111 & cd2125=0b10000 & rA & imm {
	delayflag:1 = (rA == 0);
    delayslot(1);
    if delayflag goto imm;
}
:bneid rA, imm is op2631=0b101111 & cd2125=0b10001 & rA & imm {
	delayflag:1 = (rA != 0);
    delayslot(1);
    if delayflag goto imm;
}
:bltid rA, imm is op2631=0b101111 & cd2125=0b10010 & rA & imm {
	delayflag:1 = (rA s< 0);
    delayslot(1);
    if delayflag goto imm;
}
:bleid rA, imm is op2631=0b101111 & cd2125=0b10011 & rA & imm {
	delayflag:1 = (rA s<= 0);
    delayslot(1);
    if delayflag goto imm;
}
:bgtid rA, imm is op2631=0b101111 & cd2125=0b10100 & rA & imm {
	delayflag:1 = (rA s> 0);
    delayslot(1);
    if delayflag goto imm;
}
:bgeid rA, imm is op2631=0b101111 & cd2125=0b10101 & rA & imm {
	delayflag:1 = (rA s>= 0);
	delayslot(1);
	if delayflag goto imm;
}
:lbu rD, rA, rB is op2631=0b110000 & rD & rA & rB & cd0010=0b00000000000 unimpl
:lbur rD, rA, rB is op2631=0b110000 & rD & rA & rB & cd0010=0b01000000000 unimpl
:lbuea rD, rA, rB is op2631=0b110000 & rD & rA & rB & cd0010=0b00010000000 unimpl
:lhu rD, rA, rB is op2631=0b110001 & rD & rA & rB & cd0010=0b00000000000 unimpl
:lhur rD, rA, rB is op2631=0b110001 & rD & rA & rB & cd0010=0b01000000000 unimpl
:lhuea rD, rA, rB is op2631=0b110001 & rD & rA & rB & cd0010=0b00010000000 unimpl
:lw rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b00000000000 {
	local tmp:4 = rA + rB;
	rD = *:4 tmp;
}
:lwr rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b01000000000 unimpl
:lwx rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b10000000000 unimpl
:lwea rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b00010000000 unimpl
:sb rD, rA, rB is op2631=0b110100 & rD & rA & rB & cd0010=0b00000000000 unimpl
:sbr rD, rA, rB is op2631=0b110100 & rD & rA & rB & cd0010=0b01000000000 unimpl
:sh rD, rA, rB is op2631=0b110101 & rD & rA & rB & cd0010=0b00000000000 unimpl
:shr rD, rA, rB is op2631=0b110101 & rD & rA & rB & cd0010=0b01000000000 unimpl
:shea rD, rA, rB is op2631=0b110101 & rD & rA & rB & cd0010=0b00010000000 unimpl
:sw rD, rA, rB is op2631=0b110110 & rD & rA & rB & cd0010=0b00000000000 {
	local tmp:4 = rA + rB;
	*:4 tmp = rD;
}
:swr rD, rA, rB is op2631=0b110110 & rD & rA & rB & cd0010=0b01000000000 unimpl
:swx rD, rA, rB is op2631=0b110110 & rD & rA & rB & cd0010=0b10000000000 unimpl
:swea rD, rA, rB is op2631=0b110110 & rD & rA & rB & cd0010=0b00010000000 unimpl
:lbui rD, rA, imm is op2631=0b111000 & rD & rA & imm {
	local tmp:4 = rA + imm;
	rD = zext(*[ram]:1 tmp);
}
:lhui rD, rA, imm is op2631=0b111001 & rD & rA & imm {
	local tmp:4 = rA + imm;
	rD = zext(*[ram]:2 tmp);
}
:lwi rD, rA, imm is op2631=0b111010 & rD & rA & imm {
	local tmp:4 = rA + imm;
    rD = *[ram]:4 tmp;
}
:sbi rD, rA, imm is op2631=0b111100 & rD & rA & imm {
	local tmp:4 = rA + imm;
	*[ram]:1 tmp = rD:1;
}
:shi rD, rA, imm is op2631=0b111101 & rD & rA & imm {
	local tmp:4 = rA + imm;
	*[ram]:2 tmp = rD:2;
}
:swi rD, rA, imm is op2631=0b111110 & rD & rA & imm {
	local tmp:4 = rA + imm;
    *[ram]:4 tmp = *[ram]:4 rD;
}
:nop is op2631=0b100000 & rD=0 & rA=0 & rB=0 {
	local NOP:1 = 0;
	NOP = NOP;
}
