#sext() instructions removed, will address at later time

define endian     = $(ENDIAN);
define alignment  = 4;

define space ram      type=ram_space        size=4 default;
define space register type=register_space   size=4;

define register offset=0 size=4
  [ r0 r1 r2 r3 r4 r5 r6 r7	r8 r9 r10 r11 r12 r13 r14 r15 r16 
  r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31 ];

define register offset=0x80 size=4
  [ pc msr ear esr fsr btr edr slr shr pid zpr tlblo tlbhi tlbx tlbsx ] ;

define register offset=0xBC size=4
  [ pvr0 pvr1 pvr2 pvr3 pvr4 pvr5 pvr6 pvr7 pvr8 pvr9 pvr10 pvr11 pvr12 ] ;

# Context for 32bit immediate construction
define register offset=0x200 size=4 immstatus;
define context immstatus
  ImmMode = (0,  0)  noflow     # 1 if ImmH is enabled
  ImmH    = (16, 31) noflow
;

@define FSR_IO    "fsr[27,1]"
@define FSR_DZ    "fsr[28,1]"
@define FSR_OF    "fsr[29,1]"
@define FSR_UF    "fsr[30,1]"
@define FSR_DO    "fsr[31,1]"

@define MSR_CC    "msr[0, 1]"
@define MSR_VMS   "msr[17,1]"
@define MSR_VM    "msr[18,1]"
@define MSR_UMS   "msr[19,1]"
@define MSR_UM    "msr[20,1]"
@define MSR_PVR   "msr[21,1]"
@define MSR_EIP   "msr[22,1]"
@define MSR_EE    "msr[23,1]"
@define MSR_DCE   "msr[24,1]"
@define MSR_DZO   "msr[25,1]"
@define MSR_ICE   "msr[26,1]"
@define MSR_FSL   "msr[27,1]"
@define MSR_BIP   "msr[28,1]"
@define MSR_C     "msr[29,1]"
@define MSR_IE    "msr[30,1]"

@define ESR_DS    "esr[19,1]"
@define ESR_ESS   "esr[20,5]"
@define ESR_EC    "esr[27,5]"

macro setCF(val) {
    $(MSR_C) = val;
    $(MSR_CC) = val;
}

macro setPC(val) {
  pc = val;
}

macro swapByteOrder4(dest, src){
  dest[0,8] =  src[24,8];
  dest[8,8] =  src[16,8];
  dest[16,8] = src[8,8];
  dest[24,8] = src[0,8];
}

define token instr(32)
    op2631 = (26, 31)
    opc3   = (29, 31)
    opcsub = (26, 28)
    opc_k  = (28, 28)
    opc_c  = (27, 27)
    opc2   = (26, 26)
    rD = (21, 25)
    oprD_d = (25, 25)
    oprD_21_4 = (21, 24)
    rA = (16,20)
    oprA_d = (20, 20)
    oprA_a = (19, 19)
    oprA_l = (18, 18)
    oprA_zero = (16, 20)
    rB = (11,15)
    rS = (0,13)
    cd0010 = (0,10)
    cd0415 = (4,15)
    cd0505 = (5,5)
    cd1415 = (14,15)
    cd1620 = (16,20)
    cd2125 = (21,25)
    delay25 = (25,25)
    cd2124 = (21,24)
    imm5 = (27,31)
    imm3 = (21,25)
    immw = (6,10)
    imm = (0,15)
    imm16u = (0,15)
    imm16s = (0,15) signed
    imm14  = (0,13)
    imm15 = (0, 14)
    bs1115 = (11,15)
    bs0510 = (5,10)
    zr1415 = (14,15)
    zr15 = (15,15)
    fsl = (0,3)
;

attach variables [ rD rA rB ]
    [
        r0  r1  r2  r3  r4  r5  r6  r7
        r8  r9  r10 r11 r12 r13 r14 r15
        r16 r17 r18 r19 r20 r21 r22 r23 
        r24 r25 r26 r27 r28 r29 r30 r31 
    ];

# TypeB Immediate
TBImm: imm16s is imm16s & ImmMode=0 {
    local timm:4 = sext(imm16s:2); 
    export *[const]:4 timm; 
}
TBImm: IMM is imm16u & ImmMode=1 & ImmH
    [ IMM = (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ] 
    { export *[const]:4 IMM; }
# Addr (+Imm)
TBRel: reloc is imm16s & ImmMode=0 
  [ reloc = inst_start + imm16s; ] { export *:4 reloc; }
TBRel: reloc is imm16u & ImmMode=1 & ImmH 
  [ reloc = inst_start + (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ] 
  { export *:4 reloc; }

# Absolute Addr. (Imm)
TBAbs: imm16s is imm16s & ImmMode=0 { 
  local timms:2 = imm16s;
  local tdest:4 = sext(timms);
  export *[const]:4 tdest; 
}
TBAbs: reloc is imm16u & ImmMode=1 & ImmH 
  [ reloc = (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ]
  { export *:4 reloc; }

RegA: rA is rA { export rA; }
RegA: rA is rA & rA=0 { export 0:4; }
RegB: rB is rB { export rB; }
RegB: rB is rB & rB=0 { export 0:4; }

:imm imm16u is op2631=0b101100 & rD=0 & rA=0 & imm16u 
  [ 
    ImmMode = 1; 
    ImmH = imm16u; 
    globalset(inst_next, ImmMode); 
    globalset(inst_next, ImmH); 
  ]{}

with : opc3=0b000 & opc2=0 & cd0010=0b00000000000 {
    with : opc_k=0 { 
        :add rD, RegA, RegB is opc_c=0 & rD & RegA & RegB {
            rD = RegA + RegB;
            setCF(scarry(RegA, RegB));
        }
        :addc rD, RegA, RegB is opc_c=1 & rD & RegA & RegB {
            local tmpcf:1 = scarry(RegB, RegA);
            rD = RegB + RegA;
            tmpcf = tmpcf | scarry(rD, zext($(MSR_C)));
            rD = rD + zext($(MSR_C));
            setCF(tmpcf);
        }
    }
    with : opc_k=1 {
        :addk rD,RegA,RegB is opc_c=0 & rD & RegA & RegB { rD = RegA + RegB; }
        :addkc rD,RegA,RegB is opc_c=1 & rD & RegA & RegB { rD = RegA + RegB + zext($(MSR_C)); }
    }
}

:rsub rD, RegA, RegB is op2631=0b000001 & rD & RegA & RegB & cd0010=0b00000000000 {
    rD = RegB - RegA;
    setCF(sborrow(RegB, RegA));
}

:rsubc rD, rA, rB is op2631=0b000011 & rD & rA & rB & cd0010=0b00000000000 {
    local tmp:4 = zext($(MSR_C));
    rD = rB + ~rA + tmp;
    setCF(sborrow(rB, rA));
}

:rsubk rD, RegA, RegB is op2631=0b000101 & rD & RegA & RegB & cd0010=0b00000000000 {
    rD = RegB - RegA;
}

:cmp rD, rA, rB is op2631=0b000101 & rD & rA & rB & cd0010=0b00000000001 {
	rD = rB + ~rA + 1;
    rD[31,1] = (rA s> rB);
}

:cmpu rD, rA, rB is op2631=0b000101 & rD & rA & rB & cd0010=0b00000000011 {
	rD = rB + ~rA + 1;
	rD[31,1] = (rA > rB);
}
:rsubkc rD, rA, rB is op2631=0b000111 & rD & rA & rB & cd0010=0b00000000000 {
  local tmp:4 = zext($(MSR_C));
  rD = rB + ~rA + tmp;
}

with : opc3=0b001 & opc2=0 {
    :addi rD,RegA,TBImm is opc_k=0 & opc_c=0 & rD & RegA & TBImm {
        rD = RegA + TBImm;
        setCF(scarry(RegA, TBImm));
    }
    :addic rD,RegA,TBImm is opc_k=0 & opc_c=1 & rD & RegA & TBImm {
        local tmpCF:1 = scarry(RegA, TBImm);
        rD = RegA + TBImm;
        tmpCF = tmpCF | scarry(rD, zext($(MSR_C)));
        rD = rD + zext($(MSR_C));
        setCF(tmpCF);
    }
    :addik rD,RegA,TBImm is opc_k=1 & opc_c=0 & rD & RegA & TBImm {
        rD = RegA + TBImm;
    }
    :addikc rD,RegA,TBImm is opc_k=1 & opc_c=1 & rD & RegA & TBImm {
        rD = RegA + TBImm + zext($(MSR_C));
    }
} # opc=0b001 (addi)

:rsubi rD, rA, imm is op2631=0b001001 & rD & rA & imm {
	rD = imm + ~rA + 1;
	$(MSR_C) = sborrow(imm, rA);
}

:rsubic rD, rA, imm is op2631=0b001011 & rD & rA & imm {
    local tmp:4 = zext($(MSR_C));
    rD = imm + ~rA + tmp;
	  $(MSR_C) = sborrow(imm, rA);
}

:rsubik rD, rA, imm is op2631=0b001101 & rD & rA & imm {
    rD = imm + ~rA + 1;
}

:rsubikc rD, rA, imm is op2631=0b001111 & rD & rA & imm {
    local tmp:4 = zext($(MSR_C));
    rD = imm + ~rA + tmp;
}

:mul rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rA * rB;
}

:mulh rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000001 {
	rD = (rA * rB) s>> 32;
}
:mulhu rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000011 {
	rD = (rA * rB) >> 32;
}
:mulhsu rD, rA, rB is op2631=0b010000 & rD & rA & rB & cd0010=0b00000000010 {
	rD = (rA * rB) s>> 32;
}

:idiv rD, rA, rB is op2631=0b010010 & rD & rA & rB & cd0010=0b00000000000 {
	rD = rB s/ rA;
}
:idivu rD, rA, rB is op2631=0b010010 & rD & rA & rB & cd0010=0b00000000010 {
	rD = rB / rA;
}

:fadd rD, rA, rB      is op2631=0b010110 & rD & rA & rB & cd0010=0b00000000000 {
    rD = rB f+ rA;
}

:frsub rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00010000000 {
  rD = rB f- rA;
}

:fmul rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00100000000 {
  rD = rB f* rA;
}

:fdiv rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b00110000000 {
  rD = rB f/ rA;
}

:fcmp.un rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000000000 {
  local tmp:1 = nan(rA) || nan(rB);
  rD = zext(tmp);
}

:fcmp.lt rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000010000{
  local tmp:1 = rB f< rA;
  rD = zext(tmp);
}

:fcmp.eq rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000100000 {
  local tmp:1 = rB f== rA;
  rD = zext(tmp);
}

:fcmp.le rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01000110000 {
  local tmp:1 = rB f<= rA;
  rD = zext(tmp);
}

:fcmp.gt rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001000000 {
  local tmp:1 = rB f> rA;
  rD = zext(tmp);
}

:fcmp.ne rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001010000 {
  local tmp:1 = rB f!= rA;
  rD = zext(tmp);
}

:fcmp.ge rD, rA, rB is op2631=0b010110 & rD & rA & rB & cd0010=0b01001100000 {
  local tmp:1 = rB f>= rA;
  rD = zext(tmp);
}

:flt rD, rA is op2631=0b010110 & rD & rA & imm16u=0b0000001010000000 {
  rD = int2float(rA);
}

:fint rD, rA is op2631=0b010110 & rD & rA & imm16u=0b0000001100000000 {
  rD = trunc(rA);
}

:fsqrt rD, rA is op2631=0b010110 & rD & rA & imm16u=0b0000001110000000 { rD = sqrt(rA); }
:muli rD, rA, imm is op2631=0b011000 & rD & rA & imm { rD = rA * imm; }

with : op2631=0b011001 {
  with : bs1115=0 {
    :bsrli rD,rA,imm5 is rD & rA & bs0510=0b000000 & imm5 { rD = rA >> imm5; }
    :bsrai rD,rA,imm5 is rD & rA & bs0510=0b010000 & imm5 { rD = rA s>> imm5; }
    :bslli rD,rA,imm5 is rD & rA & bs0510=0b100000 & imm5 { rD = rA << imm5; }
  } # bs1115=0
  :bsefi rD, rA, immw, imm5 is rD & rA & bs1115=0b01000 & immw & cd0505=0 & imm5 {
      local mask:4 = ~(0xFFFFFFFF << immw);
      rD = (rA >> imm5) & mask;
  }
  :bsifi rD, rA, immw, imm5 is rD & rA & bs1115=0b10000 & immw & cd0505=0 & imm5 {
      local mask:4 = (0xFFFFFFFF << (immw + 1)) ^ (0xFFFFFFFF << imm5);
      rD = ((rA << imm5) & mask)|(rD & mask);
  }
}

with : op2631=0b010001 {
  :bsrl rD, rA, rB is rD & rA & rB & cd0010=0b00000000000 { rD = rA >> rB; }
  :bsra rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 { rD = rA s>> rB; }
  :bsll rD, rA, rB is rD & rA & rB & cd0010=0b10000000000 { rD = rA << rB; }
}

with :cd0010=0b00000000000 {
  :or rD,RegA,RegB   is op2631=0b100000 & rD & RegA & RegB { rD = RegA | RegB; }
  :and rD,RegA,RegB  is op2631=0b100001 & rD & RegA & RegB { rD = RegA & RegB; }
  :xor rD,RegA,RegB  is op2631=0b100010 & rD & RegA & RegB { rD = RegA ^ RegB; }
  :andn rD,RegA,RegB is op2631=0b100011 & rD & RegA & RegB { rD = RegA & ~RegB; }
} # with cd0010=0b00000000000
with : op2631=0b100100 {
  :sra rD, RegA is rD & RegA & imm16u=0b0000000000000001 { 
    rD = RegA s>> 1;
    setCF(RegA[0,1]);
  }
  :src rD, RegA is rD & RegA & imm16u=0b0000000000100001 { 
    rD = RegA >> 1;
    rD[31,1] = $(MSR_C);
    setCF(RegA[0,1]);
  }
  :srl rD, RegA is rD & RegA & imm16u=0b0000000001000001 { rD = RegA >> 1; }
  :sext8 rD, rA is rD & rA & imm16u=0b0000000001100000 {
    local tmp:1 = rA[0,8];
    rD = sext(tmp);
  }
  :sext16 rD, rA is rD & rA & imm16u=0b0000000001100001 {
    local tmp:2 = rA[0,16];
    rD = sext(tmp);
  }
  :clz rD, rA is rD & rA & imm16u=0b0000000011100000 unimpl
  :swapb rD, RegA is rD & RegA & imm16u=0b0000000111100000 {
      swapByteOrder4(rD, RegA);
  }
  :swaph rD, RegA is rD & RegA & imm16u=0b0000000111100010 {
      tmp:4 = RegA;
      rD[0,16] = tmp[16,16];
      rD[16,16] = tmp[0,16];
  }
  :wic rA, rB           is cd2125=0b00000 & rA & rB & cd0010=0b00001101000 unimpl
  :wdc rA, rB           is cd2125=0b00000 & rA & rB & cd0010=0b00001100100 unimpl
  :wdc.flush rA, rB     is cd2125=0b00000 & rA & rB & cd0010=0b00001110100 unimpl
  :wdc.clear rA, rB     is cd2125=0b00000 & rA & rB & cd0010=0b00001100110 unimpl
  :wdc.clear.ea rA, rB  is cd2125=0b00000 & rA & rB & cd0010=0b00011100110 unimpl   
} # with op2631=0b100100

@include "mb_spreg.sinc"

# opADelay: "d" is oprA_d=1 { delayslot(1); export 1:1; }
# opADelay:     is oprA_d=0 { export 0:1; }
# brDest: "a" is oprA_a=1 { export 1:1; }
# brDest:     is oprA_a=0 { export 0:1; }
# opALink: "l" is oprA_l=1 & rD { rD = inst_start; export 1:1; }
# opALink:     is oprA_l=0 { export 0:1; }

with: op2631=0b100110 & cd0010=0b00000000000 {
    :br  RegB is rD=0 & cd1620=0 & RegB {
      local dest:4 = RegB + inst_start;
      goto [dest];
    }

    :brd RegB is rD=0 & cd1620=0b10000 & RegB {
      local dest:4 = RegB + inst_start;
      delayslot(1);
      goto [dest];
    }

    :brld rD,RegB is rD & cd1620=0b10100 & RegB {
        rD = inst_start;
        local dest:4 = RegB + inst_start;
        delayslot(1);
        call [dest];
    }
    
    :bra RegB is cd2125=0 & cd1620=0b01000 & RegB {
        goto [RegB];
    }
    :brad RegB is cd2125=0 & cd1620=0b11000 & RegB {
        delayslot(1);
        goto [RegB];
    }
    :brald rD, RegB is rD & cd1620=0b11100 & RegB {
        build RegB;
        rD = inst_start;
        delayslot(1);
        call [RegB];
    }
}

:brk rD, rB is op2631=0b100110 & rD & cd1620=0b01100 & rB & cd0010=0b00000000000 unimpl
:beq rA, rB is op2631=0b100111 & cd2125=0b00000 & rA & rB & cd0010=0b00000000000 unimpl
:bne rA, rB is op2631=0b100111 & cd2125=0b00001 & rA & rB & cd0010=0b00000000000 unimpl
:blt rA, rB is op2631=0b100111 & cd2125=0b00010 & rA & rB & cd0010=0b00000000000 unimpl
:ble rA, rB is op2631=0b100111 & cd2125=0b00011 & rA & rB & cd0010=0b00000000000 unimpl
:bgt rA, rB is op2631=0b100111 & cd2125=0b00100 & rA & rB & cd0010=0b00000000000 unimpl
:bge rA, rB is op2631=0b100111 & cd2125=0b00101 & rA & rB & cd0010=0b00000000000 unimpl
:beqd rA, rB is op2631=0b100111 & cd2125=0b10000 & rA & rB & cd0010=0b00000000000 unimpl
:bned rA, rB is op2631=0b100111 & cd2125=0b10001 & rA & rB & cd0010=0b00000000000 unimpl
:bltd rA, rB is op2631=0b100111 & cd2125=0b10010 & rA & rB & cd0010=0b00000000000 unimpl
:bled rA, rB is op2631=0b100111 & cd2125=0b10011 & rA & rB & cd0010=0b00000000000 unimpl
:bgtd rA, rB is op2631=0b100111 & cd2125=0b10100 & rA & rB & cd0010=0b00000000000 unimpl
:bged rA, rB is op2631=0b100111 & cd2125=0b10101 & rA & rB & cd0010=0b00000000000 unimpl

:ori rD,RegA,TBImm   is op2631=0b101000 & rD & RegA & TBImm { rD = RegA | TBImm; }
:andi rD,RegA,TBImm  is op2631=0b101001 & rD & RegA & TBImm { rD = RegA & TBImm; }
:xori rD,RegA,TBImm  is op2631=0b101010 & rD & RegA & TBImm { rD = RegA ^ TBImm; }
:andni rD,RegA,TBImm is op2631=0b101011 & rD & RegA & TBImm { rD = RegA & ~TBImm; }


with : op2631=0b101110 {
  :bri  TBRel is rD=0 & cd1620=0 & TBRel {
    goto TBRel;
  }
  
  :brid TBRel is rD=0 & cd1620=0b10000 & TBRel {
    delayslot(1);
    goto TBRel;
  }
  
  :brlid rD, TBRel is rD & cd1620=0b10100 & TBRel {
    delayslot(1);
    rD = inst_start;
    call TBRel;
  }

  :brai TBAbs      is rD=0 & cd1620=0b01000 & TBAbs {
    goto TBAbs;
  }

  :braid TBAbs     is rD=0 & cd1620=0b11000 & TBAbs {
    delayslot(1);
    goto TBAbs;
  }
  :bralid rD          is rD   & cd1620=0b11100 & TBAbs {
    delayslot(1);
    rD = inst_start;
    call TBAbs;
  }
  :mbar imm3          is imm3 & cd1620=0b00010 & imm16u=0b0000000000000100 unimpl
  :brki rD, TBImm     is rD & cd1620=0b01100 & TBImm unimpl
}

# Conditional branch
with : op2631=0b101111 {
  :beqi rA, TBRel is cd2125=0b00000 & rA & TBRel {
    local tflg:1 = (rA == 0);
    if (tflg) goto TBRel;
  }
  :bnei rA, TBRel is cd2125=0b00001 & rA & TBRel {
    local tflg:1 = (rA != 0);
    if tflg goto TBRel;
  }

  :blti rA, TBRel is cd2125=0b00010 & rA & TBRel {
    local tflg:1 = (rA s< 0);
    if tflg goto TBRel;
  }

  :blei rA, TBRel is cd2125=0b00011 & rA & TBRel {
    local tflg:1 = (rA s<= 0);
    if tflg goto TBRel;
  }

  :bgti rA, TBRel is cd2125=0b00100 & rA & TBRel {
    local tflg:1 = (rA s> 0);
    if tflg goto TBRel;
  }

  :bgei rA, TBRel is cd2125=0b00101 & rA & TBRel {
    local tflg:1 = (rA s>= 0);
    if tflg goto TBRel;
  }

  :beqid rA, TBRel is cd2125=0b10000 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA == 0);
    if tflg goto TBRel;
  }

  :bneid rA, TBRel is cd2125=0b10001 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA != 0);
    if tflg goto TBRel;
  }

  :bltid rA, TBRel is cd2125=0b10010 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s< 0);
    if tflg goto TBRel;
  }

  :bleid rA, TBRel is cd2125=0b10011 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s<= 0);
    if tflg goto TBRel;
  }

  :bgtid rA, TBRel is cd2125=0b10100 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s> 0);
    if tflg goto TBRel;
  }

  :bgeid rA, TBRel is cd2125=0b10101 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s>= 0);
    if tflg goto TBRel;
  }
} # with op2631=0b101111

with : op2631=0b110000 {
    :lbu rD, rA, rB is rD & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        rD = zext(*:1 tmp);
    }
    :lbur rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :lbuea rD, rA, rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

with : op2631=0b110001 {
    :lhu rD,rA,rB is rD & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        rD = zext(*:2 tmp);
    }
    :lhur rD,rA,rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :lhuea rD,rA,rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

:lw rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b00000000000 {
	local tmp:4 = rA + rB;
	rD = *:4 tmp;
}
:lwr rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b01000000000 {
  local tmp:4 = rA + rB;
  local tv:4 = *:4 tmp;
  swapByteOrder4(rD, tv);
}
:lwx rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b10000000000 unimpl
:lwea rD, rA, rB is op2631=0b110010 & rD & rA & rB & cd0010=0b00010000000 unimpl
RDest: rD is rD & rD=0 { export 0:4; }
RDest: rD is rD { export rD; }
with : op2631=0b110100 {
    :sb  RDest, rA, rB is RDest & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        *:1 tmp = RDest;
    }
    :sbr rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
}

with : op2631=0b110101 {
    :sh  rD, rA, rB is rD & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        *:2 tmp = rD;
    }
    :shr rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :shea rD, rA, rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

with : op2631=0b110110 {
    :sw RDest, rA, rB is  RDest & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        *:4 tmp = RDest;
    }
    :swr rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :swx rD, rA, rB is rD & rA & rB & cd0010=0b10000000000 unimpl
    :swea rD, rA, rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

:lbui rD, RegA, TBImm is op2631=0b111000 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	rD = zext(*[ram]:1 tmp);
}
:lhui rD, RegA, TBImm is op2631=0b111001 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	rD = zext(*[ram]:2 tmp);
}
:lwi rD, RegA, TBImm is op2631=0b111010 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
    rD = *[ram]:4 tmp;
}
:sbi RDest, RegA, TBImm is op2631=0b111100 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	*[ram]:1 tmp = RDest:1;
}
:shi RDest, RegA, TBImm is op2631=0b111101 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	*[ram]:2 tmp = RDest:2;
}
:swi RDest, RegA, TBImm is op2631=0b111110 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
    *[ram]:4 tmp = RDest;
}

@include "pcmp.sinc"
@include "mb_stream.sinc"
