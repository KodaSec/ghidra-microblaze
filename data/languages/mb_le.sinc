#sext() instructions removed, will address at later time

define endian     = $(ENDIAN);
define alignment  = 4;

define space ram      type=ram_space        size=4 default;
define space register type=register_space   size=4;

define register offset=0 size=4
  [ r0 r1 r2 r3 r4 r5 r6 r7	r8 r9 r10 r11 r12 r13 r14 r15 r16 
  r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31 ];

define register offset=0x80 size=4
  [ pc msr ear esr fsr btr edr slr shr pid zpr tlblo tlbhi tlbx tlbsx ] ;

define register offset=0xBC size=4
  [ pvr0 pvr1 pvr2 pvr3 pvr4 pvr5 pvr6 pvr7 pvr8 pvr9 pvr10 pvr11 pvr12 ] ;

# Context for 32bit immediate construction
define register offset=0x200 size=4 immstatus;
define context immstatus
  ImmMode = (0,  0)  noflow     # 1 if ImmH is enabled
  ImmH    = (16, 31) noflow
;

@define FSR_IO    "fsr[27,1]"
@define FSR_DZ    "fsr[28,1]"
@define FSR_OF    "fsr[29,1]"
@define FSR_UF    "fsr[30,1]"
@define FSR_DO    "fsr[31,1]"

# MSR
# 31  30  29  28  27  26  25  24  23  22  21  20  19  18  17  16
# CC [                                    RESERVED             ]
#  15  14  13  12  11  10  9   8   7   6   5   4   3   2   1    0
# RES VMS  VM UMS  UM PVR EIP EE DCE DZO ICE FSL BIP   C  IE  RES
@define MSR_CC    "msr[31,1]"
@define MSR_VMS   "msr[14,1]"
@define MSR_VM    "msr[13,1]"
@define MSR_UMS   "msr[12,1]"
@define MSR_UM    "msr[11,1]"
@define MSR_PVR   "msr[10,1]"
@define MSR_EIP   "msr[9,1]"
@define MSR_EE    "msr[8,1]"
@define MSR_DCE   "msr[7,1]"
@define MSR_DZO   "msr[6,1]"
@define MSR_ICE   "msr[5,1]"
@define MSR_FSL   "msr[4,1]"
@define MSR_BIP   "msr[3,1]"
@define MSR_C     "msr[2,1]"
@define MSR_IE    "msr[1,1]"

@define ESR_DS    "esr[19,1]"
@define ESR_ESS   "esr[20,5]"
@define ESR_EC    "esr[27,5]"

# MSR macros
macro setCF(val) {
    $(MSR_C) = val;
    $(MSR_CC) = val;
}

macro setMSR_BIPF(val){ $(MSR_BIP) = val; }
macro setMSR_IEF(val){ $(MSR_BIP) = val; }

macro setPC(val) {
  pc = val;
}

macro swapByteOrder4(dest, src){
  dest[0,8] =  src[24,8];
  dest[8,8] =  src[16,8];
  dest[16,8] = src[8,8];
  dest[24,8] = src[0,8];
}

define token instr(32)
    op2631 = (26, 31)
    opc3   = (29, 31)
    opcsub = (26, 28)
    opc_k  = (28, 28)
    opc_c  = (27, 27)
    opc2   = (26, 26)
    rD = (21, 25)
    oprD_d = (25, 25)
    oprD_21_4 = (21, 24)
    rA = (16,20)
    oprA_d = (20, 20)
    oprA_a = (19, 19)
    oprA_l = (18, 18)
    oprA_zero = (16, 20)
    rB = (11,15)
    rS = (0,13)
    cd0010 = (0,10)
    cd0415 = (4,15)
    cd0505 = (5,5)
    cd1415 = (14,15)
    cd1620 = (16,20)
    cd2125 = (21,25)
    delay25 = (25,25)
    cd2124 = (21,24)
    imm3 = (21,25)
    immw = (6,10)
    imm = (0,15)
    imm_bs_shift_size = (0, 4)
    imm16u = (0,15)
    imm16s = (0,15) signed
    imm14  = (0,13)
    imm15 = (0, 14)
    bs1115 = (11,15)
    bs0510 = (5,10)
    zr1415 = (14,15)
    zr15 = (15,15)
    fsl = (0,3)
    # brX
    # [20:16] = { delay, abs, link, ext[1:0] }
      br_enable_delay = (20, 20)
      br_oprA_flg_abs = (19, 19)
      br_oprA_ext     = (16, 18)
;

attach variables [ rD rA rB ]
    [
        r0  r1  r2  r3  r4  r5  r6  r7
        r8  r9  r10 r11 r12 r13 r14 r15
        r16 r17 r18 r19 r20 r21 r22 r23 
        r24 r25 r26 r27 r28 r29 r30 r31 
    ];

# TypeB Immediate
TBImm: imm16s is imm16s & ImmMode=0 {
    local timm:4 = sext(imm16s:2); 
    export *[const]:4 timm; 
}
TBImm: IMM is imm16u & ImmMode=1 & ImmH
    [ IMM = (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ] 
    { export *[const]:4 IMM; }
# Addr (+Imm)
TBRel: reloc is imm16s & ImmMode=0 
  [ reloc = inst_start + imm16s; ] { export *:4 reloc; }
TBRel: reloc is imm16u & ImmMode=1 & ImmH 
  [ reloc = inst_start + (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ] 
  { export *:4 reloc; }

# Absolute Addr. (Imm)
TBAbs: imm16s is imm16s & ImmMode=0 { 
  local timms:2 = imm16s;
  local tdest:4 = sext(timms);
  export *[const]:4 tdest; 
}
TBAbs: reloc is imm16u & ImmMode=1 & ImmH 
  [ reloc = (((ImmH $and 0x0000FFFF)<<16) $or (imm16u $and 0x0000FFFF)); ]
  { export *:4 reloc; }

RegA: rA is rA { export rA; }
RegA: rA is rA & rA=0 { export 0:4; }
RegB: rB is rB { export rB; }
RegB: rB is rB & rB=0 { export 0:4; }

@include "mb_insts_fp.sinc"

:imm imm16u is op2631=0b101100 & rD=0 & rA=0 & imm16u 
  [ 
    ImmMode = 1; 
    ImmH = imm16u; 
    globalset(inst_next, ImmMode); 
    globalset(inst_next, ImmH); 
  ]{}

with : opc3=0b000 & opc2=0 & cd0010=0b00000000000 {
    with : opc_k=0 { 
        :add rD, RegA, RegB is opc_c=0 & rD & RegA & RegB {
            rD = RegA + RegB;
            setCF(scarry(RegA, RegB));
        }
        :addc rD, RegA, RegB is opc_c=1 & rD & RegA & RegB {
            local tmpcf:1 = scarry(RegB, RegA);
            rD = RegB + RegA;
            tmpcf = tmpcf | scarry(rD, zext($(MSR_C)));
            rD = rD + zext($(MSR_C));
            setCF(tmpcf);
        }
    }
    with : opc_k=1 {
        :addk rD,RegA,RegB is opc_c=0 & rD & RegA & RegB { rD = RegA + RegB; }
        :addkc rD,RegA,RegB is opc_c=1 & rD & RegA & RegB { rD = RegA + RegB + zext($(MSR_C)); }
    }
}

with : opc3=0b000 & opc2=1 { # rsub/cmp
    :rsub   rD,RegA,RegB is opc_k=0 & opc_c=0 & rD & RegA & RegB & cd0010=0b00000000000 {
        rD = RegB - RegA;
        setCF(sborrow(RegB, RegA));
    }
    :rsubc  rD,RegA,RegB is opc_k=0 & opc_c=1 & rD & RegA & RegB & cd0010=0b00000000000 {
        local tmp:4 = zext($(MSR_C));
        rD = RegB + ~RegA + tmp;
        setCF(sborrow(RegB, RegA));
    }
    :rsubk  rD,RegA,RegB is opc_k=1 & opc_c=0 & rD & RegA & RegB & cd0010=0b00000000000 {
        rD = RegB - RegA;
    }
    :rsubkc rD,RegA,RegB is opc_k=1 & opc_c=1 & rD & RegA & RegB & cd0010=0b00000000000 {
        local tmp:4 = zext($(MSR_C));
        rD = RegB + ~RegA + tmp;
    }
    :cmp    rD,RegA,RegB is opc_k=1 & opc_c=0 & rD & RegA & RegB & cd0010=0b00000000001 {
        rD = RegB - RegA;
        rD[31,1] = (RegA s> RegB);
    }
    :cmpu   rD,RegA,RegB is opc_k=1 & opc_c=0 & rD & RegA & RegB & cd0010=0b00000000011 {
        rD = RegB - RegA;
        rD[31,1] = (RegA > RegB);
    }
} # rsub/cmp

with : opc3=0b001 {
    with : opc2=0 { # addi[kc]
        :addi rD,RegA,TBImm is opc_k=0 & opc_c=0 & rD & RegA & TBImm {
            rD = RegA + TBImm;
            setCF(scarry(RegA, TBImm));
        }
        :addic rD,RegA,TBImm is opc_k=0 & opc_c=1 & rD & RegA & TBImm {
            local tmpCF:1 = scarry(RegA, TBImm);
            rD = RegA + TBImm;
            tmpCF = tmpCF | scarry(rD, zext($(MSR_C)));
            rD = rD + zext($(MSR_C));
            setCF(tmpCF);
        }
        :addik rD,RegA,TBImm is opc_k=1 & opc_c=0 & rD & RegA & TBImm {
            rD = RegA + TBImm;
        }
        :addikc rD,RegA,TBImm is opc_k=1 & opc_c=1 & rD & RegA & TBImm {
            rD = RegA + TBImm + zext($(MSR_C));
        }
    } # opc2=0 (addi[kc])

    with : opc2=1 { # rsubi[kc]
        :rsubi   rD,RegA,TBImm is opc_k=0 & opc_c=0 & rD & RegA & TBImm {
          rD = TBImm + ~RegA + 1;
          setCF(~sborrow(TBImm, RegA));
        }
        :rsubic  rD,RegA,TBImm is opc_k=0 & opc_c=1 & rD & RegA & TBImm {
            local tmp:4 = zext($(MSR_C));
            rD = TBImm + ~RegA + tmp;
            setCF(~sborrow(TBImm, RegA));
        }
        :rsubik  rD,RegA,TBImm is opc_k=1 & opc_c=0 & rD & RegA & TBImm {
            rD = TBImm - RegA;
        }
        :rsubikc rD,RegA,TBImm is opc_k=1 & opc_c=1 & rD & RegA & TBImm {
            local tmp:4 = zext($(MSR_C));
            rD = TBImm + ~RegA + tmp;
        }
    } # opc2=1 (rsubi[kc])
} # opc3=0b001 (addi/subi)

with : opc3=0b010 & opc_k=0 & opc_c=0 & opc2=0 {
    :mul rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000000 {
        rD = RegA * RegB;
    }
    :mulh rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000001 {
        local tmp:8 = sext(RegA) * sext(RegB);
        rD = tmp[32, 32];
    }
    :mulhu rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000011 {
        local tmp:8 = zext(RegA) * zext(RegB);
        rD = tmp[32, 32];
    }
    :mulhsu rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000010 {
        local tmp:8 = sext(RegA) * zext(RegB);
        rD = tmp[32, 32];
    }
}
:muli rD,RegA,TBImm is op2631=0b011000 & rD & RegA & TBImm { rD = RegA * TBImm; }

with : op2631=0b010010 {
    :idiv  rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000000 { rD = RegB s/ RegA; }
    :idivu rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000010 { rD = RegB / RegA; }
}

with : op2631=0b011001 {
    with : bs1115=0 {
        :bsrli rD,rA,imm_bs_shift_size is rD & rA & bs0510=0b000000 & imm_bs_shift_size { rD = rA >>  imm_bs_shift_size; }
        :bsrai rD,rA,imm_bs_shift_size is rD & rA & bs0510=0b010000 & imm_bs_shift_size { rD = rA s>> imm_bs_shift_size; }
        :bslli rD,rA,imm_bs_shift_size is rD & rA & bs0510=0b100000 & imm_bs_shift_size { rD = rA <<  imm_bs_shift_size; }
    } # bs1115=0
    :bsefi rD, rA, immw, imm_bs_shift_size is rD & rA & bs1115=0b01000 & immw & cd0505=0 & imm_bs_shift_size {
        local mask:4 = ~(0xFFFFFFFF << immw);
        rD = (rA >> imm_bs_shift_size) & mask;
    }
    :bsifi rD, rA, immw, imm_bs_shift_size is rD & rA & bs1115=0b10000 & immw & cd0505=0 & imm_bs_shift_size {
        local mask:4 = (0xFFFFFFFF << (immw + 1)) ^ (0xFFFFFFFF << imm_bs_shift_size);
        rD = ((rA << imm_bs_shift_size) & mask)|(rD & mask);
    }
}

with : op2631=0b010001 {
  :bsrl rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000000 { rD = RegA >> RegB; }
  :bsra rD,RegA,RegB is rD & RegA & RegB & cd0010=0b01000000000 { rD = RegA s>> RegB; }
  :bsll rD,RegA,RegB is rD & RegA & RegB & cd0010=0b10000000000 { rD = RegA << RegB; }
}

with :cd0010=0b00000000000 {
  :or   rD,RegA,RegB is op2631=0b100000 & rD & RegA & RegB { rD = RegA | RegB; }
  :and  rD,RegA,RegB is op2631=0b100001 & rD & RegA & RegB { rD = RegA & RegB; }
  :xor  rD,RegA,RegB is op2631=0b100010 & rD & RegA & RegB { rD = RegA ^ RegB; }
  :andn rD,RegA,RegB is op2631=0b100011 & rD & RegA & RegB { rD = RegA & ~RegB; }
} # with cd0010=0b00000000000

with : op2631=0b100100 {
  :sra rD, RegA is rD & RegA & imm16u=0b0000000000000001 { 
    rD = RegA s>> 1;
    setCF(RegA[0,1]);
  }
  :src rD, RegA is rD & RegA & imm16u=0b0000000000100001 { 
    rD = RegA >> 1;
    rD[31,1] = $(MSR_C);
    setCF(RegA[0,1]);
  }
  :srl rD, RegA is rD & RegA & imm16u=0b0000000001000001 { rD = RegA >> 1; }
  :sext8 rD, RegA is rD & RegA & imm16u=0b0000000001100000 {
    local tmp:1 = RegA[0,8];
    rD = sext(tmp);
  }
  :sext16 rD, RegA is rD & RegA & imm16u=0b0000000001100001 {
    local tmp:2 = RegA[0,16];
    rD = sext(tmp);
  }
  :clz rD, RegA is rD & RegA & imm16u=0b0000000011100000 unimpl
  :swapb rD, RegA is rD & RegA & imm16u=0b0000000111100000 {
      swapByteOrder4(rD, RegA);
  }
  :swaph rD, RegA is rD & RegA & imm16u=0b0000000111100010 {
      tmp:4 = RegA;
      rD[0,16] = tmp[16,16];
      rD[16,16] = tmp[0,16];
  }
  :wic rA, rB           is cd2125=0b00000 & rA & rB & cd0010=0b00001101000 unimpl
  :wdc rA, rB           is cd2125=0b00000 & rA & rB & cd0010=0b00001100100 unimpl
  :wdc.flush rA, rB     is cd2125=0b00000 & rA & rB & cd0010=0b00001110100 unimpl
  :wdc.clear rA, rB     is cd2125=0b00000 & rA & rB & cd0010=0b00001100110 unimpl
  :wdc.clear.ea rA, rB  is cd2125=0b00000 & rA & rB & cd0010=0b00011100110 unimpl   
} # with op2631=0b100100

@include "mb_spreg.sinc"

# opADelay: "d" is oprA_d=1 { delayslot(1); export 1:1; }
# opADelay:     is oprA_d=0 { export 0:1; }
# brDest: "a" is oprA_a=1 { export 1:1; }
# brDest:     is oprA_a=0 { export 0:1; }
# opALink: "l" is oprA_l=1 & rD { rD = inst_start; export 1:1; }
# opALink:     is oprA_l=0 { export 0:1; }

BRFlagDelay: "d" is br_enable_delay=1 { delayslot(1); export 1:1; }
BRFlagDelay:     is br_enable_delay=0 { export 0:1; }

with: op2631=0b100110 & cd0010=0b00000000000 {
    :br^BRFlagDelay RegB is rD=0 & BRFlagDelay & br_oprA_flg_abs=0 & br_oprA_ext=0 & RegB {
      local dest:4 = RegB + inst_start;
      setPC(dest);
      build BRFlagDelay;
      goto [pc];
    }
    
    :brld rD,RegB is rD & cd1620=0b10100 & RegB {
        rD = inst_start;
        local dest:4 = RegB + inst_start;
        delayslot(1);
        call [dest];
    }

    :bra^BRFlagDelay RegB is rD=0 & BRFlagDelay & br_oprA_flg_abs=1 & br_oprA_ext=0 & RegB {
        local dest:4 = RegB;
        build BRFlagDelay;
        goto [dest];
    }

    :brald rD,RegB is rD & cd1620=0b11100 & RegB {
        rD = inst_start;
        local dest:4 = RegB;
        delayslot(1);
        call [dest];
    }

    :brk rD,RegB is rD & cd1620=0b01100 & RegB {
        rD = inst_start;
        local dest:4 = RegB;
        setPC(dest);
        setMSR_BIPF(1:1);
        goto [pc];
    }
}

:beq  rA,rB is op2631=0b100111 & cd2125=0b00000 & rA & rB & cd0010=0b00000000000 unimpl
:beqd rA,rB is op2631=0b100111 & cd2125=0b10000 & rA & rB & cd0010=0b00000000000 unimpl
:bne  rA,rB is op2631=0b100111 & cd2125=0b00001 & rA & rB & cd0010=0b00000000000 unimpl
:bned rA,rB is op2631=0b100111 & cd2125=0b10001 & rA & rB & cd0010=0b00000000000 unimpl
:blt  rA,rB is op2631=0b100111 & cd2125=0b00010 & rA & rB & cd0010=0b00000000000 unimpl
:bltd rA,rB is op2631=0b100111 & cd2125=0b10010 & rA & rB & cd0010=0b00000000000 unimpl
:ble  rA,rB is op2631=0b100111 & cd2125=0b00011 & rA & rB & cd0010=0b00000000000 unimpl
:bled rA,rB is op2631=0b100111 & cd2125=0b10011 & rA & rB & cd0010=0b00000000000 unimpl
:bgt  rA,rB is op2631=0b100111 & cd2125=0b00100 & rA & rB & cd0010=0b00000000000 unimpl
:bgtd rA,rB is op2631=0b100111 & cd2125=0b10100 & rA & rB & cd0010=0b00000000000 unimpl
:bge  rA,rB is op2631=0b100111 & cd2125=0b00101 & rA & rB & cd0010=0b00000000000 unimpl
:bged rA,rB is op2631=0b100111 & cd2125=0b10101 & rA & rB & cd0010=0b00000000000 unimpl

:ori rD,RegA,TBImm   is op2631=0b101000 & rD & RegA & TBImm { rD = RegA | TBImm; }
:andi rD,RegA,TBImm  is op2631=0b101001 & rD & RegA & TBImm { rD = RegA & TBImm; }
:xori rD,RegA,TBImm  is op2631=0b101010 & rD & RegA & TBImm { rD = RegA ^ TBImm; }
:andni rD,RegA,TBImm is op2631=0b101011 & rD & RegA & TBImm { rD = RegA & ~TBImm; }

with : op2631=0b101110 {
  :bri TBRel       is rD=0 & cd1620=0b00000 & TBRel {
      goto TBRel;
  }
  :brid TBRel      is rD=0 & cd1620=0b10000 & TBRel {
      delayslot(1);
      goto TBRel;
  }
  :brlid rD, TBRel is rD & cd1620=0b10100 & TBRel {
      delayslot(1);
      rD = inst_start;
      call TBRel;
  }

  :brai TBAbs      is rD=0 & cd1620=0b01000 & TBAbs {
    goto TBAbs;
  }

  :braid TBAbs     is rD=0 & cd1620=0b11000 & TBAbs {
    delayslot(1);
    goto TBAbs;
  }
  :bralid rD          is rD   & cd1620=0b11100 & TBAbs {
    delayslot(1);
    rD = inst_start;
    call TBAbs;
  }

  :brki rD, TBAbs is rD & cd1620=0b01100 & TBAbs {
      rD = inst_start;
      setPC(TBAbs);
      goto [pc];
  }

  # Nothing to do
  :mbar imm3 is imm3 & cd1620=0b00010 & imm16u=0b0000000000000100 {}
}

# Conditional branch
with : op2631=0b101111 {
  :beqi rA, TBRel is cd2125=0b00000 & rA & TBRel {
    local tflg:1 = (rA == 0);
    if (tflg) goto TBRel;
  }
  :bnei rA, TBRel is cd2125=0b00001 & rA & TBRel {
    local tflg:1 = (rA != 0);
    if tflg goto TBRel;
  }

  :blti rA, TBRel is cd2125=0b00010 & rA & TBRel {
    local tflg:1 = (rA s< 0);
    if tflg goto TBRel;
  }

  :blei rA, TBRel is cd2125=0b00011 & rA & TBRel {
    local tflg:1 = (rA s<= 0);
    if tflg goto TBRel;
  }

  :bgti rA, TBRel is cd2125=0b00100 & rA & TBRel {
    local tflg:1 = (rA s> 0);
    if tflg goto TBRel;
  }

  :bgei rA, TBRel is cd2125=0b00101 & rA & TBRel {
    local tflg:1 = (rA s>= 0);
    if tflg goto TBRel;
  }

  :beqid rA, TBRel is cd2125=0b10000 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA == 0);
    if tflg goto TBRel;
  }

  :bneid rA, TBRel is cd2125=0b10001 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA != 0);
    if tflg goto TBRel;
  }

  :bltid rA, TBRel is cd2125=0b10010 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s< 0);
    if tflg goto TBRel;
  }

  :bleid rA, TBRel is cd2125=0b10011 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s<= 0);
    if tflg goto TBRel;
  }

  :bgtid rA, TBRel is cd2125=0b10100 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s> 0);
    if tflg goto TBRel;
  }

  :bgeid rA, TBRel is cd2125=0b10101 & rA & TBRel {
    delayslot(1);
    local tflg:1 = (rA s>= 0);
    if tflg goto TBRel;
  }
} # with op2631=0b101111

with : op2631=0b110000 {
    :lbu   rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000000 {
        local tmp:4 = RegA + RegB;
        rD = zext(*:1 tmp);
    }
    :lbur  rD,RegA RegB is rD & RegA & RegB & cd0010=0b01000000000 unimpl
    :lbuea rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00010000000 unimpl
}

with : op2631=0b110001 {
    :lhu  rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00000000000 {
        local tmp:4 = RegA + RegB;
        rD = zext(*:2 tmp);
    }
    :lhur  rD,RegA,RegB is rD & RegA & RegB & cd0010=0b01000000000 unimpl
    :lhuea rD,RegA,RegB is rD & RegA & RegB & cd0010=0b00010000000 unimpl
}

:lw   rD,RegA,RegB is op2631=0b110010 & rD & RegA & RegB & cd0010=0b00000000000 {
    local tmp:4 = RegA + RegB;
    rD = *:4 tmp;
}
:lwr  rD,RegA,RegB is op2631=0b110010 & rD & RegA & RegB & cd0010=0b01000000000 {
    local tmp:4 = RegA + RegB;
    local tv:4 = *:4 tmp;
    swapByteOrder4(rD, tv);
}
:lwx  rD,RegA,RegB is op2631=0b110010 & rD & RegA & RegB & cd0010=0b10000000000 unimpl
:lwea rD,RegA,RegB is op2631=0b110010 & rD & RegA & RegB & cd0010=0b00010000000 unimpl
RDest: rD is rD & rD=0 { export 0:4; }
RDest: rD is rD { export rD; }
with : op2631=0b110100 {
    :sb  RDest, RegA, RegB is RDest & RegA & RegB & cd0010=0b00000000000 {
        local tmp:4 = RegA + RegB;
        *:1 tmp = RDest;
    }
    :sbr rD, RegA, RegB is rD & RegA & RegB & cd0010=0b01000000000 unimpl
}

with : op2631=0b110101 {
    :sh  rD, rA, rB is rD & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        *:2 tmp = rD;
    }
    :shr rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :shea rD, rA, rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

with : op2631=0b110110 {
    :sw RDest, rA, rB is  RDest & rA & rB & cd0010=0b00000000000 {
        local tmp:4 = rA + rB;
        *:4 tmp = RDest;
    }
    :swr rD, rA, rB is rD & rA & rB & cd0010=0b01000000000 unimpl
    :swx rD, rA, rB is rD & rA & rB & cd0010=0b10000000000 unimpl
    :swea rD, rA, rB is rD & rA & rB & cd0010=0b00010000000 unimpl
}

:lbui rD, RegA, TBImm is op2631=0b111000 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	rD = zext(*[ram]:1 tmp);
}
:lhui rD, RegA, TBImm is op2631=0b111001 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	rD = zext(*[ram]:2 tmp);
}
:lwi rD, RegA, TBImm is op2631=0b111010 & rD & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
    rD = *[ram]:4 tmp;
}
:sbi RDest, RegA, TBImm is op2631=0b111100 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	*[ram]:1 tmp = RDest:1;
}
:shi RDest, RegA, TBImm is op2631=0b111101 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
	*[ram]:2 tmp = RDest:2;
}
:swi RDest, RegA, TBImm is op2631=0b111110 & RDest & RegA & TBImm {
	local tmp:4 = RegA + TBImm;
    *[ram]:4 tmp = RDest;
}

@include "pcmp.sinc"
@include "mb_stream.sinc"
